


# Types de base utilisés par l'arbitre
Environment = ... # Ensemble des données utiles (cache, état de jeu...) pour
                  # que votre IA puisse jouer (objet, dictionnaire, autre...)
Cell = tuple[int, int]
ActionGopher = Cell
ActionDodo = tuple[Cell, Cell] # case de départ -> case d'arrivée
Action = ActionGopher or ActionDodo
Player = int # 1 ou 2
State = list[tuple[Cell, Player]] # État du jeu pour la boucle de jeu
Score = int
Time = int

def creermatrice(n: int):
    matrice = [[ 0 for i in range(2*n - 1)] for i in range(2 * n -1)]

    for i in range(0, n):
        for j in range(0, n - i):
            matrice[i][j] = -1

    for i in range(0, n):
        for j in range(2 * n - 2 - i, 2 * n - 1):
            matrice[n-1 + i][j] = -1
    for i in range(n*2-1):
        matrice[0][i] = -1
        matrice[-1][i] = -1
        matrice[i][0] = -1
        matrice[i][-1] = -1
    return matrice


def affichermatrice(matrice):
    print(matrice)
    sizeGrid = int((len(matrice) + 1) / 2)
    print (f"   ",([" ",i - sizeGrid," "]for i in range(2 * sizeGrid - 1)),  "\n\n")


    for i in range(len(matrice)) :
        print(" ", i + 1 - sizeGrid, " |",[( " ", matrice[i][j], " ")for j in range(len(matrice))] )
    return






def afficher_matrice(matrice):
    # Couleurs spécifiques pour chaque valeur utilisant les séquences d'échappement ANSI
    couleurs = {
        1: '\033[91m',  # Rouge
        2: '\033[94m',  # Bleu
        0: '\033[97m',  # Blanc
        -1: '\033[90m'  # Gris
    }
    reset_couleur = '\033[0m'  # Réinitialiser la couleur
    sizeGrid = int((len(matrice) + 1) / 2)

    # Obtenir les dimensions de la matrice
    n_rows = len(matrice)
    n_cols = len(matrice[0]) if n_rows > 0 else 0

    # Calculer la longueur maximale des éléments pour aligner correctement les coordonnées
    max_element_length = max(len(str(matrice[i][j])) for i in range(n_rows) for j in range(n_cols))

    # Afficher les colonnes avec les coordonnées
    print(" " * (max_element_length + 3), end='')  # Espaces pour les coordonnées de ligne
    for j in range(n_cols):
        print(f"{j-sizeGrid+1:>{max_element_length}}", end=' ')
    print()  # Nouvelle ligne

    # Afficher les lignes avec les coordonnées et les éléments de la matrice
    for i in range(n_rows):
        print(f"{i-sizeGrid+1:>{max_element_length}} |", end=' ')  # Coordonnées de ligne
        for j in range(n_cols):
            valeur = matrice[i][j]
            couleur = couleurs.get(valeur, '')  # Obtenir la couleur ou utiliser la couleur par défaut
            print(f"{couleur}{valeur:>{max_element_length}}{reset_couleur}", end=' ')
        print()  # Nouvelle ligne
    print()



def play(matrice, coup, joueur):
    # On utilise ici les coordonnés -(n-1) // n-1
    sizeGrid = int((len(matrice) + 1) / 2)
    if matrice[coup[0]+sizeGrid-1][coup[1]+sizeGrid-1] != -1:
        matrice[coup[0]+sizeGrid-1][coup[1]+sizeGrid-1] = joueur
    else :
        print("coup hors du plateau")



def getadjacent(case):
    a = case[0]
    b = case[1]
    return [[a, b+1],[a+1, b+1],[a+1, b],[a-1, b],[a-1, b-1],[a, b-1]]


def initialize(game: str, state: State, player: Player,
               hex_size: int, total_time: Time) -> Environment:
    x = {}
    x["game"] = game
    x["hex_size"] = hex_size
    # Pas de temps dans environnement mais pris en compte dans stratégie



    # implémenter le cache
    # implémenter la grille de jeu

    return x



def strategy(env: Environment, state: State, player: Player,
             time_left: Time) -> tuple[Environment, Action]:
    if Environment["game"] == "Gopher":
        if Environment["hex_size"] % 2 == 1 and player == 2:
            return strategy_Gopher_optimale(env: Environment, state: State, player: Player, time_left: Time)
        return strategy_Gopher(env: Environment, state: State, player: Player, time_left: Time)
    if Environment["game"] == "Dodo":
        return strategy_Dodo(env: Environment, state: State, player: Player, time_left: Time)
    return [0,0]
            

def final_result(state: State, score: Score, player: Player):
    
    
    # Pour faire des stats ou changer notre stratégie
    
    return


def strategy_Gopher(env: Environment, state: State, player: Player, time_left: Time) -> tuple[Environment, Action] :
    
     return 





def test():
    a = creermatrice(7)
    afficher_matrice(a)
    play(a, [0,-6], 2)
    play(a, [0, -5], 2)
    play(a, [0, -4], 2)
    play(a, [0, -3], 2)
    play(a, [0, -2], 2)
    play(a, [-6,0], 1)
    play(a, [-5,0], 1)
    play(a, [-4,0], 1)
    play(a, [-3,0], 1)
    play(a, [-2,0], 1)
    afficher_matrice(a)
    return

if __name__ == '__main__':

    test()